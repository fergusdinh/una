import {
  GraphQLResolveInfo,
  GraphQLScalarType,
  GraphQLScalarTypeConfig,
} from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
  [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: any;
  ISO8601Date: any;
  ISO8601DateTime: any;
  JSON: any;
};

/** Autogenerated input type of AcceptInvite */
export type AcceptInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
  /** Uniq token of the Invite */
  token: Scalars['String'];
};

export type AddOn = {
  __typename?: 'AddOn';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** Check if add-on is deletable */
  canBeDeleted: Scalars['Boolean'];
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Number of customers using this add-on */
  customerCount: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type AddOnCollection = {
  __typename?: 'AddOnCollection';
  collection: Array<AddOn>;
  metadata: CollectionMetadata;
};

export type AddOnDetails = {
  __typename?: 'AddOnDetails';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** Check if add-on is deletable */
  canBeDeleted: Scalars['Boolean'];
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Number of customers using this add-on */
  customerCount: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** Autogenerated input type of AddStripePaymentProvider */
export type AddStripePaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  createCustomers?: InputMaybe<Scalars['Boolean']>;
  secretKey?: InputMaybe<Scalars['String']>;
};

export enum AggregationTypeEnum {
  CountAgg = 'count_agg',
  MaxAgg = 'max_agg',
  RecurringCountAgg = 'recurring_count_agg',
  SumAgg = 'sum_agg',
  UniqueCountAgg = 'unique_count_agg',
}

export type AppliedAddOn = {
  __typename?: 'AppliedAddOn';
  addOn: AddOn;
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
};

export type AppliedCoupon = {
  __typename?: 'AppliedCoupon';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  coupon: Coupon;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  terminatedAt: Scalars['ISO8601DateTime'];
};

export type BillableMetric = {
  __typename?: 'BillableMetric';
  aggregationType: AggregationTypeEnum;
  /** Check if billable metric is deletable */
  canBeDeleted: Scalars['Boolean'];
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type BillableMetricCollection = {
  __typename?: 'BillableMetricCollection';
  collection: Array<BillableMetric>;
  metadata: CollectionMetadata;
};

export type BillableMetricDetail = {
  __typename?: 'BillableMetricDetail';
  aggregationType: AggregationTypeEnum;
  /** Check if billable metric is deletable */
  canBeDeleted: Scalars['Boolean'];
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  description?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export enum BillingTimeEnum {
  Anniversary = 'anniversary',
  Calendar = 'calendar',
}

export type Charge = {
  __typename?: 'Charge';
  amount?: Maybe<Scalars['String']>;
  billableMetric: BillableMetric;
  chargeModel: ChargeModelEnum;
  createdAt: Scalars['ISO8601DateTime'];
  fixedAmount?: Maybe<Scalars['String']>;
  freeUnits?: Maybe<Scalars['Int']>;
  freeUnitsPerEvents?: Maybe<Scalars['Int']>;
  freeUnitsPerTotalAggregation?: Maybe<Scalars['String']>;
  graduatedRanges?: Maybe<Array<GraduatedRange>>;
  id: Scalars['ID'];
  packageSize?: Maybe<Scalars['Int']>;
  rate?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
  volumeRanges?: Maybe<Array<VolumeRange>>;
};

export type ChargeInput = {
  amount?: InputMaybe<Scalars['String']>;
  billableMetricId: Scalars['ID'];
  chargeModel: ChargeModelEnum;
  fixedAmount?: InputMaybe<Scalars['String']>;
  freeUnits?: InputMaybe<Scalars['Int']>;
  freeUnitsPerEvents?: InputMaybe<Scalars['Int']>;
  freeUnitsPerTotalAggregation?: InputMaybe<Scalars['String']>;
  graduatedRanges?: InputMaybe<Array<GraduatedRangeInput>>;
  id?: InputMaybe<Scalars['ID']>;
  packageSize?: InputMaybe<Scalars['Int']>;
  rate?: InputMaybe<Scalars['String']>;
  volumeRanges?: InputMaybe<Array<VolumeRangeInput>>;
};

export enum ChargeModelEnum {
  Graduated = 'graduated',
  Package = 'package',
  Percentage = 'percentage',
  Standard = 'standard',
  Volume = 'volume',
}

export type ChargeUsage = {
  __typename?: 'ChargeUsage';
  amountCents: Scalars['BigInt'];
  billableMetric: BillableMetric;
  charge: Charge;
  units: Scalars['Float'];
};

export type CollectionMetadata = {
  __typename?: 'CollectionMetadata';
  currentPage: Scalars['Int'];
  limitValue: Scalars['Int'];
  totalCount: Scalars['Int'];
  totalPages: Scalars['Int'];
};

export enum CountryCode {
  /** Andorra */
  Ad = 'AD',
  /** United Arab Emirates */
  Ae = 'AE',
  /** Afghanistan */
  Af = 'AF',
  /** Antigua and Barbuda */
  Ag = 'AG',
  /** Anguilla */
  Ai = 'AI',
  /** Albania */
  Al = 'AL',
  /** Armenia */
  Am = 'AM',
  /** Angola */
  Ao = 'AO',
  /** Antarctica */
  Aq = 'AQ',
  /** Argentina */
  Ar = 'AR',
  /** American Samoa */
  As = 'AS',
  /** Austria */
  At = 'AT',
  /** Australia */
  Au = 'AU',
  /** Aruba */
  Aw = 'AW',
  /** Åland Islands */
  Ax = 'AX',
  /** Azerbaijan */
  Az = 'AZ',
  /** Bosnia and Herzegovina */
  Ba = 'BA',
  /** Barbados */
  Bb = 'BB',
  /** Bangladesh */
  Bd = 'BD',
  /** Belgium */
  Be = 'BE',
  /** Burkina Faso */
  Bf = 'BF',
  /** Bulgaria */
  Bg = 'BG',
  /** Bahrain */
  Bh = 'BH',
  /** Burundi */
  Bi = 'BI',
  /** Benin */
  Bj = 'BJ',
  /** Saint Barthélemy */
  Bl = 'BL',
  /** Bermuda */
  Bm = 'BM',
  /** Brunei Darussalam */
  Bn = 'BN',
  /** Bolivia (Plurinational State of) */
  Bo = 'BO',
  /** Bonaire, Sint Eustatius and Saba */
  Bq = 'BQ',
  /** Brazil */
  Br = 'BR',
  /** Bahamas */
  Bs = 'BS',
  /** Bhutan */
  Bt = 'BT',
  /** Bouvet Island */
  Bv = 'BV',
  /** Botswana */
  Bw = 'BW',
  /** Belarus */
  By = 'BY',
  /** Belize */
  Bz = 'BZ',
  /** Canada */
  Ca = 'CA',
  /** Cocos (Keeling) Islands */
  Cc = 'CC',
  /** Congo (Democratic Republic of the) */
  Cd = 'CD',
  /** Central African Republic */
  Cf = 'CF',
  /** Congo */
  Cg = 'CG',
  /** Switzerland */
  Ch = 'CH',
  /** Côte d'Ivoire */
  Ci = 'CI',
  /** Cook Islands */
  Ck = 'CK',
  /** Chile */
  Cl = 'CL',
  /** Cameroon */
  Cm = 'CM',
  /** China */
  Cn = 'CN',
  /** Colombia */
  Co = 'CO',
  /** Costa Rica */
  Cr = 'CR',
  /** Cuba */
  Cu = 'CU',
  /** Cabo Verde */
  Cv = 'CV',
  /** Curaçao */
  Cw = 'CW',
  /** Christmas Island */
  Cx = 'CX',
  /** Cyprus */
  Cy = 'CY',
  /** Czechia */
  Cz = 'CZ',
  /** Germany */
  De = 'DE',
  /** Djibouti */
  Dj = 'DJ',
  /** Denmark */
  Dk = 'DK',
  /** Dominica */
  Dm = 'DM',
  /** Dominican Republic */
  Do = 'DO',
  /** Algeria */
  Dz = 'DZ',
  /** Ecuador */
  Ec = 'EC',
  /** Estonia */
  Ee = 'EE',
  /** Egypt */
  Eg = 'EG',
  /** Western Sahara */
  Eh = 'EH',
  /** Eritrea */
  Er = 'ER',
  /** Spain */
  Es = 'ES',
  /** Ethiopia */
  Et = 'ET',
  /** Finland */
  Fi = 'FI',
  /** Fiji */
  Fj = 'FJ',
  /** Falkland Islands (Malvinas) */
  Fk = 'FK',
  /** Micronesia (Federated States of) */
  Fm = 'FM',
  /** Faroe Islands */
  Fo = 'FO',
  /** France */
  Fr = 'FR',
  /** Gabon */
  Ga = 'GA',
  /** United Kingdom of Great Britain and Northern Ireland */
  Gb = 'GB',
  /** Grenada */
  Gd = 'GD',
  /** Georgia */
  Ge = 'GE',
  /** French Guiana */
  Gf = 'GF',
  /** Guernsey */
  Gg = 'GG',
  /** Ghana */
  Gh = 'GH',
  /** Gibraltar */
  Gi = 'GI',
  /** Greenland */
  Gl = 'GL',
  /** Gambia */
  Gm = 'GM',
  /** Guinea */
  Gn = 'GN',
  /** Guadeloupe */
  Gp = 'GP',
  /** Equatorial Guinea */
  Gq = 'GQ',
  /** Greece */
  Gr = 'GR',
  /** South Georgia and the South Sandwich Islands */
  Gs = 'GS',
  /** Guatemala */
  Gt = 'GT',
  /** Guam */
  Gu = 'GU',
  /** Guinea-Bissau */
  Gw = 'GW',
  /** Guyana */
  Gy = 'GY',
  /** Hong Kong */
  Hk = 'HK',
  /** Heard Island and McDonald Islands */
  Hm = 'HM',
  /** Honduras */
  Hn = 'HN',
  /** Croatia */
  Hr = 'HR',
  /** Haiti */
  Ht = 'HT',
  /** Hungary */
  Hu = 'HU',
  /** Indonesia */
  Id = 'ID',
  /** Ireland */
  Ie = 'IE',
  /** Israel */
  Il = 'IL',
  /** Isle of Man */
  Im = 'IM',
  /** India */
  In = 'IN',
  /** British Indian Ocean Territory */
  Io = 'IO',
  /** Iraq */
  Iq = 'IQ',
  /** Iran (Islamic Republic of) */
  Ir = 'IR',
  /** Iceland */
  Is = 'IS',
  /** Italy */
  It = 'IT',
  /** Jersey */
  Je = 'JE',
  /** Jamaica */
  Jm = 'JM',
  /** Jordan */
  Jo = 'JO',
  /** Japan */
  Jp = 'JP',
  /** Kenya */
  Ke = 'KE',
  /** Kyrgyzstan */
  Kg = 'KG',
  /** Cambodia */
  Kh = 'KH',
  /** Kiribati */
  Ki = 'KI',
  /** Comoros */
  Km = 'KM',
  /** Saint Kitts and Nevis */
  Kn = 'KN',
  /** Korea (Democratic People's Republic of) */
  Kp = 'KP',
  /** Korea (Republic of) */
  Kr = 'KR',
  /** Kuwait */
  Kw = 'KW',
  /** Cayman Islands */
  Ky = 'KY',
  /** Kazakhstan */
  Kz = 'KZ',
  /** Lao People's Democratic Republic */
  La = 'LA',
  /** Lebanon */
  Lb = 'LB',
  /** Saint Lucia */
  Lc = 'LC',
  /** Liechtenstein */
  Li = 'LI',
  /** Sri Lanka */
  Lk = 'LK',
  /** Liberia */
  Lr = 'LR',
  /** Lesotho */
  Ls = 'LS',
  /** Lithuania */
  Lt = 'LT',
  /** Luxembourg */
  Lu = 'LU',
  /** Latvia */
  Lv = 'LV',
  /** Libya */
  Ly = 'LY',
  /** Morocco */
  Ma = 'MA',
  /** Monaco */
  Mc = 'MC',
  /** Moldova (Republic of) */
  Md = 'MD',
  /** Montenegro */
  Me = 'ME',
  /** Saint Martin (French part) */
  Mf = 'MF',
  /** Madagascar */
  Mg = 'MG',
  /** Marshall Islands */
  Mh = 'MH',
  /** North Macedonia */
  Mk = 'MK',
  /** Mali */
  Ml = 'ML',
  /** Myanmar */
  Mm = 'MM',
  /** Mongolia */
  Mn = 'MN',
  /** Macao */
  Mo = 'MO',
  /** Northern Mariana Islands */
  Mp = 'MP',
  /** Martinique */
  Mq = 'MQ',
  /** Mauritania */
  Mr = 'MR',
  /** Montserrat */
  Ms = 'MS',
  /** Malta */
  Mt = 'MT',
  /** Mauritius */
  Mu = 'MU',
  /** Maldives */
  Mv = 'MV',
  /** Malawi */
  Mw = 'MW',
  /** Mexico */
  Mx = 'MX',
  /** Malaysia */
  My = 'MY',
  /** Mozambique */
  Mz = 'MZ',
  /** Namibia */
  Na = 'NA',
  /** New Caledonia */
  Nc = 'NC',
  /** Niger */
  Ne = 'NE',
  /** Norfolk Island */
  Nf = 'NF',
  /** Nigeria */
  Ng = 'NG',
  /** Nicaragua */
  Ni = 'NI',
  /** Netherlands */
  Nl = 'NL',
  /** Norway */
  No = 'NO',
  /** Nepal */
  Np = 'NP',
  /** Nauru */
  Nr = 'NR',
  /** Niue */
  Nu = 'NU',
  /** New Zealand */
  Nz = 'NZ',
  /** Oman */
  Om = 'OM',
  /** Panama */
  Pa = 'PA',
  /** Peru */
  Pe = 'PE',
  /** French Polynesia */
  Pf = 'PF',
  /** Papua New Guinea */
  Pg = 'PG',
  /** Philippines */
  Ph = 'PH',
  /** Pakistan */
  Pk = 'PK',
  /** Poland */
  Pl = 'PL',
  /** Saint Pierre and Miquelon */
  Pm = 'PM',
  /** Pitcairn */
  Pn = 'PN',
  /** Puerto Rico */
  Pr = 'PR',
  /** Palestine, State of */
  Ps = 'PS',
  /** Portugal */
  Pt = 'PT',
  /** Palau */
  Pw = 'PW',
  /** Paraguay */
  Py = 'PY',
  /** Qatar */
  Qa = 'QA',
  /** Réunion */
  Re = 'RE',
  /** Romania */
  Ro = 'RO',
  /** Serbia */
  Rs = 'RS',
  /** Russian Federation */
  Ru = 'RU',
  /** Rwanda */
  Rw = 'RW',
  /** Saudi Arabia */
  Sa = 'SA',
  /** Solomon Islands */
  Sb = 'SB',
  /** Seychelles */
  Sc = 'SC',
  /** Sudan */
  Sd = 'SD',
  /** Sweden */
  Se = 'SE',
  /** Singapore */
  Sg = 'SG',
  /** Saint Helena, Ascension and Tristan da Cunha */
  Sh = 'SH',
  /** Slovenia */
  Si = 'SI',
  /** Svalbard and Jan Mayen */
  Sj = 'SJ',
  /** Slovakia */
  Sk = 'SK',
  /** Sierra Leone */
  Sl = 'SL',
  /** San Marino */
  Sm = 'SM',
  /** Senegal */
  Sn = 'SN',
  /** Somalia */
  So = 'SO',
  /** Suriname */
  Sr = 'SR',
  /** South Sudan */
  Ss = 'SS',
  /** Sao Tome and Principe */
  St = 'ST',
  /** El Salvador */
  Sv = 'SV',
  /** Sint Maarten (Dutch part) */
  Sx = 'SX',
  /** Syrian Arab Republic */
  Sy = 'SY',
  /** Eswatini */
  Sz = 'SZ',
  /** Turks and Caicos Islands */
  Tc = 'TC',
  /** Chad */
  Td = 'TD',
  /** French Southern Territories */
  Tf = 'TF',
  /** Togo */
  Tg = 'TG',
  /** Thailand */
  Th = 'TH',
  /** Tajikistan */
  Tj = 'TJ',
  /** Tokelau */
  Tk = 'TK',
  /** Timor-Leste */
  Tl = 'TL',
  /** Turkmenistan */
  Tm = 'TM',
  /** Tunisia */
  Tn = 'TN',
  /** Tonga */
  To = 'TO',
  /** Turkey */
  Tr = 'TR',
  /** Trinidad and Tobago */
  Tt = 'TT',
  /** Tuvalu */
  Tv = 'TV',
  /** Taiwan, Province of China */
  Tw = 'TW',
  /** Tanzania, United Republic of */
  Tz = 'TZ',
  /** Ukraine */
  Ua = 'UA',
  /** Uganda */
  Ug = 'UG',
  /** United States Minor Outlying Islands */
  Um = 'UM',
  /** United States of America */
  Us = 'US',
  /** Uruguay */
  Uy = 'UY',
  /** Uzbekistan */
  Uz = 'UZ',
  /** Holy See */
  Va = 'VA',
  /** Saint Vincent and the Grenadines */
  Vc = 'VC',
  /** Venezuela (Bolivarian Republic of) */
  Ve = 'VE',
  /** Virgin Islands (British) */
  Vg = 'VG',
  /** Virgin Islands (U.S.) */
  Vi = 'VI',
  /** Viet Nam */
  Vn = 'VN',
  /** Vanuatu */
  Vu = 'VU',
  /** Wallis and Futuna */
  Wf = 'WF',
  /** Samoa */
  Ws = 'WS',
  /** Yemen */
  Ye = 'YE',
  /** Mayotte */
  Yt = 'YT',
  /** South Africa */
  Za = 'ZA',
  /** Zambia */
  Zm = 'ZM',
  /** Zimbabwe */
  Zw = 'ZW',
}

export type Coupon = {
  __typename?: 'Coupon';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** Check if coupon is deletable */
  canBeDeleted: Scalars['Boolean'];
  code?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  /** Number of customers using this coupon */
  customerCount: Scalars['Int'];
  expiration: CouponExpiration;
  expirationDate?: Maybe<Scalars['ISO8601Date']>;
  expirationDuration?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  status: CouponStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type CouponCollection = {
  __typename?: 'CouponCollection';
  collection: Array<Coupon>;
  metadata: CollectionMetadata;
};

export type CouponDetails = {
  __typename?: 'CouponDetails';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** Check if coupon is deletable */
  canBeDeleted: Scalars['Boolean'];
  code?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  /** Number of customers using this coupon */
  customerCount: Scalars['Int'];
  expiration: CouponExpiration;
  expirationDate?: Maybe<Scalars['ISO8601Date']>;
  expirationDuration?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  status: CouponStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export enum CouponExpiration {
  NoExpiration = 'no_expiration',
  TimeLimit = 'time_limit',
}

export enum CouponStatusEnum {
  Active = 'active',
  Terminated = 'terminated',
}

/** Autogenerated input type of CreateAddOn */
export type CreateAddOnInput = {
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

/** Autogenerated input type of CreateAppliedAddOn */
export type CreateAppliedAddOnInput = {
  addOnId: Scalars['ID'];
  amountCents?: InputMaybe<Scalars['Int']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  customerId: Scalars['ID'];
};

/** Autogenerated input type of CreateAppliedCoupon */
export type CreateAppliedCouponInput = {
  amountCents?: InputMaybe<Scalars['Int']>;
  amountCurrency?: InputMaybe<CurrencyEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  couponId: Scalars['ID'];
  customerId: Scalars['ID'];
};

/** Autogenerated input type of CreateBillableMetric */
export type CreateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code: Scalars['String'];
  description: Scalars['String'];
  fieldName?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

/** Autogenerated input type of CreateCoupon */
export type CreateCouponInput = {
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
  expiration: CouponExpiration;
  expirationDuration?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
};

/** Autogenerated input type of CreateCustomer */
export type CreateCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']>;
  addressLine2?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  email?: InputMaybe<Scalars['String']>;
  externalId: Scalars['String'];
  legalName?: InputMaybe<Scalars['String']>;
  legalNumber?: InputMaybe<Scalars['String']>;
  logoUrl?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  phone?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  stripeCustomer?: InputMaybe<StripeCustomerInput>;
  url?: InputMaybe<Scalars['String']>;
  vatRate?: InputMaybe<Scalars['Float']>;
  zipcode?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCustomerWallet */
export type CreateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  customerId: Scalars['ID'];
  expirationDate?: InputMaybe<Scalars['ISO8601Date']>;
  grantedCredits: Scalars['String'];
  name?: InputMaybe<Scalars['String']>;
  paidCredits: Scalars['String'];
  rateAmount: Scalars['String'];
};

/** Autogenerated input type of CreateCustomerWalletTransaction */
export type CreateCustomerWalletTransactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  grantedCredits: Scalars['String'];
  paidCredits: Scalars['String'];
  walletId: Scalars['ID'];
};

/** Autogenerated input type of CreateInvite */
export type CreateInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
};

/** Autogenerated input type of CreatePlan */
export type CreatePlanInput = {
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  interval: PlanInterval;
  name: Scalars['String'];
  parentId?: InputMaybe<Scalars['ID']>;
  payInAdvance: Scalars['Boolean'];
  trialPeriod?: InputMaybe<Scalars['Float']>;
};

/** Autogenerated input type of CreateSubscription */
export type CreateSubscriptionInput = {
  billingTime: BillingTimeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  customerId: Scalars['ID'];
  name?: InputMaybe<Scalars['String']>;
  planId: Scalars['ID'];
  subscriptionId?: InputMaybe<Scalars['ID']>;
};

export enum CurrencyEnum {
  /** United Arab Emirates dirham */
  Aed = 'AED',
  /** Afghan afghani */
  Afn = 'AFN',
  /** Albanian lek */
  All = 'ALL',
  /** Armenian dram */
  Amd = 'AMD',
  /** Netherlands Antillean guilder */
  Ang = 'ANG',
  /** Angolan kwanza */
  Aoa = 'AOA',
  /** Argentine peso */
  Ars = 'ARS',
  /** Australian dollar */
  Aud = 'AUD',
  /** Aruban florin */
  Awg = 'AWG',
  /** Azerbaijani manat */
  Azn = 'AZN',
  /** Bosnia and Herzegovina convertible mark */
  Bam = 'BAM',
  /** Barbados dollar */
  Bbd = 'BBD',
  /** Bangladeshi taka */
  Bdt = 'BDT',
  /** Bulgarian lev */
  Bgn = 'BGN',
  /** Bahraini dinar */
  Bif = 'BIF',
  /** Burundian franc */
  Bmd = 'BMD',
  /** Bermudian dollar */
  Bnd = 'BND',
  /** Brunei dollar */
  Bob = 'BOB',
  /** Boliviano */
  Brl = 'BRL',
  /** Brazilian real */
  Bsd = 'BSD',
  /** Bahamian dollar */
  Bwp = 'BWP',
  /** Botswana pula */
  Byn = 'BYN',
  /** Belarusian ruble */
  Bzd = 'BZD',
  /** Belize dollar */
  Cad = 'CAD',
  /** Canadian dollar */
  Cdf = 'CDF',
  /** Congolese franc */
  Chf = 'CHF',
  /** Swiss franc */
  Clp = 'CLP',
  /** Chilean peso */
  Cny = 'CNY',
  /** Colombian peso */
  Cop = 'COP',
  /** Costa Rican colon */
  Crc = 'CRC',
  /** Cape Verdean escudo */
  Cve = 'CVE',
  /** Czech koruna */
  Czk = 'CZK',
  /** Djiboutian franc */
  Djf = 'DJF',
  /** Danish krone */
  Dkk = 'DKK',
  /** Dominican peso */
  Dop = 'DOP',
  /** Algerian dinar */
  Dzd = 'DZD',
  /** Egyptian pound */
  Egp = 'EGP',
  /** Ethiopian birr */
  Etb = 'ETB',
  /** Euro */
  Eur = 'EUR',
  /** Fiji dollar */
  Fjd = 'FJD',
  /** Falkland Islands pound */
  Fkp = 'FKP',
  /** Pound sterling */
  Gbp = 'GBP',
  /** Georgian lari */
  Gel = 'GEL',
  /** Gibraltar pound */
  Gip = 'GIP',
  /** Gambian dalasi */
  Gmd = 'GMD',
  /** Guinean franc */
  Gnf = 'GNF',
  /** Guatemalan quetzal */
  Gtq = 'GTQ',
  /** Guyanese dollar */
  Gyd = 'GYD',
  /** Hong Kong dollar */
  Hkd = 'HKD',
  /** Honduran lempira */
  Hnl = 'HNL',
  /** Croatian kuna */
  Hrk = 'HRK',
  /** Haitian gourde */
  Htg = 'HTG',
  /** Hungarian forint */
  Huf = 'HUF',
  /** Indonesian Rupiah */
  Idr = 'IDR',
  /** Israeli new shekel */
  Ils = 'ILS',
  /** Indian rupee */
  Inr = 'INR',
  /** Icelandic króna */
  Isk = 'ISK',
  /** Jamaican dollar */
  Jmd = 'JMD',
  /** Japanese yen */
  Jpy = 'JPY',
  /** Kenyan shilling */
  Kes = 'KES',
  /** Kyrgyzstani som */
  Kgs = 'KGS',
  /** Cambodian riel */
  Khr = 'KHR',
  /** Comoro franc */
  Kmf = 'KMF',
  /** South Korean won */
  Krw = 'KRW',
  /** Cayman Islands dollar */
  Kyd = 'KYD',
  /** Kazakhstani tenge */
  Kzt = 'KZT',
  /** Lao kip */
  Lak = 'LAK',
  /** Lebanese pound */
  Lbp = 'LBP',
  /** Sri Lankan rupee */
  Lkr = 'LKR',
  /** Liberian dollar */
  Lrd = 'LRD',
  /** Lesotho loti */
  Lsl = 'LSL',
  /** Moroccan dirham */
  Mad = 'MAD',
  /** Moldovan leu */
  Mdl = 'MDL',
  /** Malagasy ariary */
  Mga = 'MGA',
  /** Macedonian denar */
  Mkd = 'MKD',
  /** Myanmar kyat */
  Mmk = 'MMK',
  /** Mongolian tögrög */
  Mnt = 'MNT',
  /** Macanese pataca */
  Mop = 'MOP',
  /** Mauritanian ouguiya */
  Mro = 'MRO',
  /** Mauritian rupee */
  Mur = 'MUR',
  /** Maldivian rufiyaa */
  Mvr = 'MVR',
  /** Malawian kwacha */
  Mwk = 'MWK',
  /** Mexican peso */
  Mxn = 'MXN',
  /** Malaysian ringgit */
  Myr = 'MYR',
  /** Mozambican metical */
  Mzn = 'MZN',
  /** Namibian dollar */
  Nad = 'NAD',
  /** Nigerian naira */
  Ngn = 'NGN',
  /** Nicaraguan córdoba */
  Nio = 'NIO',
  /** Norwegian Krone */
  Nok = 'NOK',
  /** Nepalese rupee */
  Npr = 'NPR',
  /** New Zealand dollar */
  Nzd = 'NZD',
  /** Panamanian balboa */
  Pab = 'PAB',
  /** Peruvian sol */
  Pen = 'PEN',
  /** Papua New Guinean kina */
  Pgk = 'PGK',
  /** Philippine peso */
  Php = 'PHP',
  /** Pakistani rupee */
  Pkr = 'PKR',
  /** Polish złoty */
  Pln = 'PLN',
  /** Paraguayan guaraní */
  Pyg = 'PYG',
  /** Qatari riyal */
  Qar = 'QAR',
  /** Romanian leu */
  Ron = 'RON',
  /** Serbian dinar */
  Rsd = 'RSD',
  /** Russian ruble */
  Rub = 'RUB',
  /** Rwandan franc */
  Rwf = 'RWF',
  /** Saudi riyal */
  Sar = 'SAR',
  /** Solomon Islands dollar */
  Sbd = 'SBD',
  /** Seychelles rupee */
  Scr = 'SCR',
  /** Swedish Krona */
  Sek = 'SEK',
  /** Singapore dollar */
  Sgd = 'SGD',
  /** Saint Helena pound */
  Shp = 'SHP',
  /** Sierra Leonean leone */
  Sll = 'SLL',
  /** Somali shilling */
  Sos = 'SOS',
  /** Surinamese dollar */
  Srd = 'SRD',
  /** São Tomé and Príncipe dobra */
  Std = 'STD',
  /** Swazi lilangeni */
  Szl = 'SZL',
  /** Thai baht */
  Thb = 'THB',
  /** Tajikistani somoni */
  Tjs = 'TJS',
  /** Tongan paʻanga */
  Top = 'TOP',
  /** Turkish lira */
  Try = 'TRY',
  /** Trinidad and Tobago dollar */
  Ttd = 'TTD',
  /** New Taiwan dollar */
  Twd = 'TWD',
  /** Tanzanian shilling */
  Tzs = 'TZS',
  /** Ukrainian hryvnia */
  Uah = 'UAH',
  /** Ugandan shilling */
  Ugx = 'UGX',
  /** American Dollar */
  Usd = 'USD',
  /** Uruguayan peso */
  Uyu = 'UYU',
  /** Uzbekistan som */
  Uzs = 'UZS',
  /** Vietnamese đồng */
  Vnd = 'VND',
  /** Vanuatu vatu */
  Vuv = 'VUV',
  /** Samoan tala */
  Wst = 'WST',
  /** CFA franc BEAC */
  Xaf = 'XAF',
  /** East Caribbean dollar */
  Xcd = 'XCD',
  /** CFA franc BCEAO */
  Xof = 'XOF',
  /** CFP franc (franc Pacifique) */
  Xpf = 'XPF',
  /** Yemeni rial */
  Yer = 'YER',
  /** South African rand */
  Zar = 'ZAR',
  /** Zambian kwacha */
  Zmw = 'ZMW',
}

export type CurrentVersion = {
  __typename?: 'CurrentVersion';
  githubUrl: Scalars['String'];
  number: Scalars['String'];
};

export type Customer = {
  __typename?: 'Customer';
  /** Number of active subscriptions per customer */
  activeSubscriptionCount: Scalars['Int'];
  addressLine1?: Maybe<Scalars['String']>;
  addressLine2?: Maybe<Scalars['String']>;
  /** Check if customer is deletable */
  canBeDeleted: Scalars['Boolean'];
  city?: Maybe<Scalars['String']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime'];
  currency?: Maybe<CurrencyEnum>;
  email?: Maybe<Scalars['String']>;
  externalId: Scalars['String'];
  /** Define if a customer has an active wallet */
  hasActiveWallet: Scalars['Boolean'];
  id: Scalars['ID'];
  legalName?: Maybe<Scalars['String']>;
  legalNumber?: Maybe<Scalars['String']>;
  logoUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  paymentProvider?: Maybe<ProviderTypeEnum>;
  phone?: Maybe<Scalars['String']>;
  sequentialId: Scalars['String'];
  slug: Scalars['String'];
  state?: Maybe<Scalars['String']>;
  stripeCustomer?: Maybe<StripeCustomer>;
  subscriptions?: Maybe<Array<Subscription>>;
  updatedAt: Scalars['ISO8601DateTime'];
  url?: Maybe<Scalars['String']>;
  vatRate?: Maybe<Scalars['Float']>;
  zipcode?: Maybe<Scalars['String']>;
};

export type CustomerCollection = {
  __typename?: 'CustomerCollection';
  collection: Array<Customer>;
  metadata: CollectionMetadata;
};

export type CustomerDetails = {
  __typename?: 'CustomerDetails';
  /** Number of active subscriptions per customer */
  activeSubscriptionCount: Scalars['Int'];
  addressLine1?: Maybe<Scalars['String']>;
  addressLine2?: Maybe<Scalars['String']>;
  appliedAddOns?: Maybe<Array<AppliedAddOn>>;
  appliedCoupons?: Maybe<Array<AppliedCoupon>>;
  /** Check if customer is deletable */
  canBeDeleted: Scalars['Boolean'];
  city?: Maybe<Scalars['String']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime'];
  currency?: Maybe<CurrencyEnum>;
  email?: Maybe<Scalars['String']>;
  externalId: Scalars['String'];
  /** Define if a customer has an active wallet */
  hasActiveWallet: Scalars['Boolean'];
  id: Scalars['ID'];
  invoices?: Maybe<Array<Invoice>>;
  legalName?: Maybe<Scalars['String']>;
  legalNumber?: Maybe<Scalars['String']>;
  logoUrl?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  paymentProvider?: Maybe<ProviderTypeEnum>;
  phone?: Maybe<Scalars['String']>;
  sequentialId: Scalars['String'];
  slug: Scalars['String'];
  state?: Maybe<Scalars['String']>;
  stripeCustomer?: Maybe<StripeCustomer>;
  /** Query subscriptions of a customer */
  subscriptions: Array<Subscription>;
  updatedAt: Scalars['ISO8601DateTime'];
  url?: Maybe<Scalars['String']>;
  vatRate?: Maybe<Scalars['Float']>;
  zipcode?: Maybe<Scalars['String']>;
};

export type CustomerDetailsSubscriptionsArgs = {
  status?: InputMaybe<Array<StatusTypeEnum>>;
};

export type CustomerUsage = {
  __typename?: 'CustomerUsage';
  amountCents: Scalars['BigInt'];
  amountCurrency: CurrencyEnum;
  chargesUsage: Array<ChargeUsage>;
  fromDate: Scalars['ISO8601Date'];
  issuingDate: Scalars['ISO8601Date'];
  toDate: Scalars['ISO8601Date'];
  totalAmountCents: Scalars['BigInt'];
  totalAmountCurrency: CurrencyEnum;
  vatAmountCents: Scalars['BigInt'];
  vatAmountCurrency: CurrencyEnum;
};

/** Autogenerated input type of DestroyAddOn */
export type DestroyAddOnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DestroyAddOn */
export type DestroyAddOnPayload = {
  __typename?: 'DestroyAddOnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DestroyBillableMetric */
export type DestroyBillableMetricInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['String'];
};

/** Autogenerated return type of DestroyBillableMetric */
export type DestroyBillableMetricPayload = {
  __typename?: 'DestroyBillableMetricPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DestroyCoupon */
export type DestroyCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DestroyCoupon */
export type DestroyCouponPayload = {
  __typename?: 'DestroyCouponPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DestroyCustomer */
export type DestroyCustomerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DestroyCustomer */
export type DestroyCustomerPayload = {
  __typename?: 'DestroyCustomerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DestroyPaymentProvider */
export type DestroyPaymentProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DestroyPaymentProvider */
export type DestroyPaymentProviderPayload = {
  __typename?: 'DestroyPaymentProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DestroyPlan */
export type DestroyPlanInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DestroyPlan */
export type DestroyPlanPayload = {
  __typename?: 'DestroyPlanPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DownloadInvoice */
export type DownloadInvoiceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

export type Event = {
  __typename?: 'Event';
  apiClient?: Maybe<Scalars['String']>;
  billableMetricName?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  externalCustomerId: Scalars['String'];
  externalSubscriptionId: Scalars['String'];
  id: Scalars['ID'];
  ipAddress?: Maybe<Scalars['String']>;
  matchBillableMetric: Scalars['Boolean'];
  matchCustomField: Scalars['Boolean'];
  payload: Scalars['JSON'];
  receivedAt: Scalars['ISO8601DateTime'];
  timestamp?: Maybe<Scalars['ISO8601DateTime']>;
  transactionId?: Maybe<Scalars['String']>;
};

export type EventCollection = {
  __typename?: 'EventCollection';
  collection: Array<Event>;
  metadata: CollectionMetadata;
};

export type GraduatedRange = {
  __typename?: 'GraduatedRange';
  flatAmount: Scalars['String'];
  fromValue: Scalars['Int'];
  perUnitAmount: Scalars['String'];
  toValue?: Maybe<Scalars['Int']>;
};

export type GraduatedRangeInput = {
  flatAmount: Scalars['String'];
  fromValue: Scalars['Int'];
  perUnitAmount: Scalars['String'];
  toValue?: InputMaybe<Scalars['Int']>;
};

export type Invite = {
  __typename?: 'Invite';
  acceptedAt: Scalars['ISO8601DateTime'];
  email: Scalars['String'];
  id: Scalars['ID'];
  organization: Organization;
  recipient: Membership;
  revokedAt: Scalars['ISO8601DateTime'];
  status: InviteStatusTypeEnum;
  token: Scalars['String'];
};

export type InviteCollection = {
  __typename?: 'InviteCollection';
  collection: Array<Invite>;
  metadata: CollectionMetadata;
};

export enum InviteStatusTypeEnum {
  Accepted = 'accepted',
  Pending = 'pending',
  Revoked = 'revoked',
}

export type Invoice = {
  __typename?: 'Invoice';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  createdAt: Scalars['ISO8601DateTime'];
  fileUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  invoiceType: InvoiceTypeEnum;
  issuingDate: Scalars['ISO8601Date'];
  number: Scalars['String'];
  plan?: Maybe<Plan>;
  sequentialId: Scalars['ID'];
  status: InvoiceStatusTypeEnum;
  subscription?: Maybe<Subscription>;
  totalAmountCents: Scalars['Int'];
  totalAmountCurrency: CurrencyEnum;
  updatedAt: Scalars['ISO8601DateTime'];
  vatAmountCents: Scalars['Int'];
  vatAmountCurrency: CurrencyEnum;
};

export enum InvoiceStatusTypeEnum {
  Failed = 'failed',
  Pending = 'pending',
  Succeeded = 'succeeded',
}

export enum InvoiceTypeEnum {
  AddOn = 'add_on',
  Credit = 'credit',
  Subscription = 'subscription',
}

export type LoginUser = {
  __typename?: 'LoginUser';
  token: Scalars['String'];
  user: User;
};

/** Autogenerated input type of LoginUser */
export type LoginUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
};

export type Membership = {
  __typename?: 'Membership';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  organization: Organization;
  revokedAt: Scalars['ISO8601DateTime'];
  role?: Maybe<Scalars['String']>;
  status: MembershipStatus;
  updatedAt: Scalars['ISO8601DateTime'];
  user: User;
};

export type MembershipCollection = {
  __typename?: 'MembershipCollection';
  collection: Array<Membership>;
  metadata: CollectionMetadata;
};

export enum MembershipStatus {
  Active = 'active',
  Revoked = 'revoked',
}

export type Mutation = {
  __typename?: 'Mutation';
  /** Accepts a new Invite */
  acceptInvite?: Maybe<RegisterUser>;
  /** Add or update Stripe API keys to the organization */
  addStripePaymentProvider?: Maybe<StripeProvider>;
  /** Creates a new add-on */
  createAddOn?: Maybe<AddOn>;
  /** Assigns an add-on to a Customer */
  createAppliedAddOn?: Maybe<AppliedAddOn>;
  /** Assigns a Coupon to a Customer */
  createAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Creates a new Billable metric */
  createBillableMetric?: Maybe<BillableMetric>;
  /** Creates a new Coupon */
  createCoupon?: Maybe<Coupon>;
  /** Creates a new customer */
  createCustomer?: Maybe<Customer>;
  /** Creates a new Customer Wallet */
  createCustomerWallet?: Maybe<Wallet>;
  /** Creates a new Customer Wallet Transaction */
  createCustomerWalletTransaction?: Maybe<WalletTransactionCollection>;
  /** Creates a new Invite */
  createInvite?: Maybe<Invite>;
  /** Creates a new Plan */
  createPlan?: Maybe<Plan>;
  /** Create a new Subscription */
  createSubscription?: Maybe<Subscription>;
  /** Deletes an add-on */
  destroyAddOn?: Maybe<DestroyAddOnPayload>;
  /** Deletes a Billable metric */
  destroyBillableMetric?: Maybe<DestroyBillableMetricPayload>;
  /** Deletes a coupon */
  destroyCoupon?: Maybe<DestroyCouponPayload>;
  /** Delete a Customer */
  destroyCustomer?: Maybe<DestroyCustomerPayload>;
  /** Destroy a payment provider */
  destroyPaymentProvider?: Maybe<DestroyPaymentProviderPayload>;
  /** Deletes a Plan */
  destroyPlan?: Maybe<DestroyPlanPayload>;
  /** Download an Invoice PDF */
  downloadInvoice?: Maybe<Invoice>;
  /** Opens a session for an existing user */
  loginUser?: Maybe<LoginUser>;
  /** Registers a new user and creates related organization */
  registerUser?: Maybe<RegisterUser>;
  /** Revokes a invite */
  revokeInvite?: Maybe<Invite>;
  /** Revoke a membership */
  revokeMembership?: Maybe<Membership>;
  /** Unassign a coupon from a customer */
  terminateAppliedCoupon?: Maybe<AppliedCoupon>;
  /** Deletes a coupon */
  terminateCoupon?: Maybe<Coupon>;
  /** Terminates a new Customer Wallet */
  terminateCustomerWallet?: Maybe<Wallet>;
  /** Terminate a Subscription */
  terminateSubscription?: Maybe<Subscription>;
  /** Update an existing add-on */
  updateAddOn?: Maybe<AddOn>;
  /** Updates an existing Billable metric */
  updateBillableMetric?: Maybe<BillableMetric>;
  /** Update an existing coupon */
  updateCoupon?: Maybe<Coupon>;
  /** Updates an existing Customer */
  updateCustomer?: Maybe<Customer>;
  /** Assign the vat rate to Customers */
  updateCustomerVatRate?: Maybe<CustomerDetails>;
  /** Updates a new Customer Wallet */
  updateCustomerWallet?: Maybe<Wallet>;
  /** Updates an Organization */
  updateOrganization?: Maybe<Organization>;
  /** Updates an existing Plan */
  updatePlan?: Maybe<Plan>;
  /** Update a Subscription */
  updateSubscription?: Maybe<Subscription>;
};

export type MutationAcceptInviteArgs = {
  input: AcceptInviteInput;
};

export type MutationAddStripePaymentProviderArgs = {
  input: AddStripePaymentProviderInput;
};

export type MutationCreateAddOnArgs = {
  input: CreateAddOnInput;
};

export type MutationCreateAppliedAddOnArgs = {
  input: CreateAppliedAddOnInput;
};

export type MutationCreateAppliedCouponArgs = {
  input: CreateAppliedCouponInput;
};

export type MutationCreateBillableMetricArgs = {
  input: CreateBillableMetricInput;
};

export type MutationCreateCouponArgs = {
  input: CreateCouponInput;
};

export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};

export type MutationCreateCustomerWalletArgs = {
  input: CreateCustomerWalletInput;
};

export type MutationCreateCustomerWalletTransactionArgs = {
  input: CreateCustomerWalletTransactionInput;
};

export type MutationCreateInviteArgs = {
  input: CreateInviteInput;
};

export type MutationCreatePlanArgs = {
  input: CreatePlanInput;
};

export type MutationCreateSubscriptionArgs = {
  input: CreateSubscriptionInput;
};

export type MutationDestroyAddOnArgs = {
  input: DestroyAddOnInput;
};

export type MutationDestroyBillableMetricArgs = {
  input: DestroyBillableMetricInput;
};

export type MutationDestroyCouponArgs = {
  input: DestroyCouponInput;
};

export type MutationDestroyCustomerArgs = {
  input: DestroyCustomerInput;
};

export type MutationDestroyPaymentProviderArgs = {
  input: DestroyPaymentProviderInput;
};

export type MutationDestroyPlanArgs = {
  input: DestroyPlanInput;
};

export type MutationDownloadInvoiceArgs = {
  input: DownloadInvoiceInput;
};

export type MutationLoginUserArgs = {
  input: LoginUserInput;
};

export type MutationRegisterUserArgs = {
  input: RegisterUserInput;
};

export type MutationRevokeInviteArgs = {
  input: RevokeInviteInput;
};

export type MutationRevokeMembershipArgs = {
  input: RevokeMembershipInput;
};

export type MutationTerminateAppliedCouponArgs = {
  input: TerminateAppliedCouponInput;
};

export type MutationTerminateCouponArgs = {
  input: TerminateCouponInput;
};

export type MutationTerminateCustomerWalletArgs = {
  input: TerminateCustomerWalletInput;
};

export type MutationTerminateSubscriptionArgs = {
  input: TerminateSubscriptionInput;
};

export type MutationUpdateAddOnArgs = {
  input: UpdateAddOnInput;
};

export type MutationUpdateBillableMetricArgs = {
  input: UpdateBillableMetricInput;
};

export type MutationUpdateCouponArgs = {
  input: UpdateCouponInput;
};

export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};

export type MutationUpdateCustomerVatRateArgs = {
  input: UpdateCustomerVatRateInput;
};

export type MutationUpdateCustomerWalletArgs = {
  input: UpdateCustomerWalletInput;
};

export type MutationUpdateOrganizationArgs = {
  input: UpdateOrganizationInput;
};

export type MutationUpdatePlanArgs = {
  input: UpdatePlanInput;
};

export type MutationUpdateSubscriptionArgs = {
  input: UpdateSubscriptionInput;
};

export type Organization = {
  __typename?: 'Organization';
  addressLine1?: Maybe<Scalars['String']>;
  addressLine2?: Maybe<Scalars['String']>;
  apiKey: Scalars['String'];
  city?: Maybe<Scalars['String']>;
  country?: Maybe<CountryCode>;
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  invoiceFooter?: Maybe<Scalars['String']>;
  legalName?: Maybe<Scalars['String']>;
  legalNumber?: Maybe<Scalars['String']>;
  logoUrl?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  state?: Maybe<Scalars['String']>;
  stripePaymentProvider?: Maybe<StripeProvider>;
  updatedAt: Scalars['ISO8601DateTime'];
  vatRate: Scalars['Float'];
  webhookUrl?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
};

export type Plan = {
  __typename?: 'Plan';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: Maybe<Scalars['Boolean']>;
  /** Check if plan is deletable */
  canBeDeleted: Scalars['Boolean'];
  /** Number of charges attached to a plan */
  chargeCount: Scalars['Int'];
  charges?: Maybe<Array<Charge>>;
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Number of customers attached to a plan */
  customerCount: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  interval: PlanInterval;
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  parentId?: Maybe<Scalars['ID']>;
  payInAdvance: Scalars['Boolean'];
  trialPeriod?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type PlanCollection = {
  __typename?: 'PlanCollection';
  collection: Array<Plan>;
  metadata: CollectionMetadata;
};

export type PlanDetails = {
  __typename?: 'PlanDetails';
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: Maybe<Scalars['Boolean']>;
  /** Check if plan is deletable */
  canBeDeleted: Scalars['Boolean'];
  /** Number of charges attached to a plan */
  chargeCount: Scalars['Int'];
  charges?: Maybe<Array<Charge>>;
  code: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  /** Number of customers attached to a plan */
  customerCount: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  interval: PlanInterval;
  name: Scalars['String'];
  organization?: Maybe<Organization>;
  parentId?: Maybe<Scalars['ID']>;
  payInAdvance: Scalars['Boolean'];
  trialPeriod?: Maybe<Scalars['Float']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export enum PlanInterval {
  Monthly = 'monthly',
  Weekly = 'weekly',
  Yearly = 'yearly',
}

export enum ProviderTypeEnum {
  Stripe = 'stripe',
}

export type Query = {
  __typename?: 'Query';
  /** Query a single add-on of an organization */
  addOn?: Maybe<AddOnDetails>;
  /** Query add-ons of an organization */
  addOns: AddOnCollection;
  /** Query a single billable metric of an organization */
  billableMetric?: Maybe<BillableMetricDetail>;
  /** Query billable metrics of an organization */
  billableMetrics: BillableMetricCollection;
  /** Query a single coupon of an organization */
  coupon?: Maybe<CouponDetails>;
  /** Query coupons of an organization */
  coupons: CouponCollection;
  /** Retrieves currently connected user */
  currentUser: User;
  /** Retrieve the version of the application */
  currentVersion: CurrentVersion;
  /** Query a single customer of an organization */
  customer?: Maybe<CustomerDetails>;
  /** Query the usage of the customer on the current billing period */
  customerUsage: CustomerUsage;
  /** Query customers of an organization */
  customers: CustomerCollection;
  /** Query events of an organization */
  events?: Maybe<EventCollection>;
  /** Query a single Invite */
  invite?: Maybe<Invite>;
  /** Query pending invites of an organization */
  invites: InviteCollection;
  /** Query memberships of an organization */
  memberships: MembershipCollection;
  /** Query a single plan of an organization */
  plan?: Maybe<PlanDetails>;
  /** Query plans of an organization */
  plans: PlanCollection;
  /** Query a single wallet */
  wallet?: Maybe<WalletDetails>;
  /** Query a single wallet transaction */
  walletTransaction?: Maybe<WalletTransactionDetails>;
  /** Query wallet transactions */
  walletTransactions: WalletTransactionCollection;
  /** Query wallets */
  wallets: WalletCollection;
};

export type QueryAddOnArgs = {
  id: Scalars['ID'];
};

export type QueryAddOnsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryBillableMetricArgs = {
  id: Scalars['ID'];
};

export type QueryBillableMetricsArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryCouponArgs = {
  id: Scalars['ID'];
};

export type QueryCouponsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<CouponStatusEnum>;
};

export type QueryCustomerArgs = {
  id: Scalars['ID'];
};

export type QueryCustomerUsageArgs = {
  customerId?: InputMaybe<Scalars['ID']>;
  subscriptionId: Scalars['ID'];
};

export type QueryCustomersArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryEventsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryInviteArgs = {
  token: Scalars['String'];
};

export type QueryInvitesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryMembershipsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryPlanArgs = {
  id: Scalars['ID'];
};

export type QueryPlansArgs = {
  ids?: InputMaybe<Array<Scalars['String']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
};

export type QueryWalletArgs = {
  id: Scalars['ID'];
};

export type QueryWalletTransactionArgs = {
  id: Scalars['ID'];
};

export type QueryWalletTransactionsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<WalletTransactionStatusEnum>;
  transactionType?: InputMaybe<WalletTransactionTransactionTypeEnum>;
  walletId: Scalars['ID'];
};

export type QueryWalletsArgs = {
  customerId: Scalars['ID'];
  ids?: InputMaybe<Array<Scalars['ID']>>;
  limit?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<WalletStatusEnum>;
};

export type RegisterUser = {
  __typename?: 'RegisterUser';
  membership: Membership;
  organization: Organization;
  token: Scalars['String'];
  user: User;
};

/** Autogenerated input type of RegisterUser */
export type RegisterUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  organizationName: Scalars['String'];
  password: Scalars['String'];
};

/** Autogenerated input type of RevokeInvite */
export type RevokeInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of RevokeMembership */
export type RevokeMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

export enum StatusTypeEnum {
  Active = 'active',
  Canceled = 'canceled',
  Pending = 'pending',
  Terminated = 'terminated',
}

export type StripeCustomer = {
  __typename?: 'StripeCustomer';
  id: Scalars['ID'];
  providerCustomerId?: Maybe<Scalars['ID']>;
};

export type StripeCustomerInput = {
  providerCustomerId?: InputMaybe<Scalars['ID']>;
};

export type StripeProvider = {
  __typename?: 'StripeProvider';
  createCustomers: Scalars['Boolean'];
  id: Scalars['ID'];
  secretKey: Scalars['String'];
};

export type Subscription = {
  __typename?: 'Subscription';
  billingTime?: Maybe<BillingTimeEnum>;
  canceledAt?: Maybe<Scalars['ISO8601DateTime']>;
  createdAt: Scalars['ISO8601DateTime'];
  customer: Customer;
  externalId: Scalars['String'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  nextName?: Maybe<Scalars['String']>;
  nextPendingStartDate?: Maybe<Scalars['ISO8601Date']>;
  nextPlan?: Maybe<Plan>;
  periodEndDate?: Maybe<Scalars['ISO8601Date']>;
  plan: Plan;
  startedAt?: Maybe<Scalars['ISO8601DateTime']>;
  status?: Maybe<StatusTypeEnum>;
  subscriptionDate?: Maybe<Scalars['ISO8601Date']>;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** Autogenerated input type of TerminateAppliedCoupon */
export type TerminateAppliedCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of TerminateCoupon */
export type TerminateCouponInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of TerminateCustomerWallet */
export type TerminateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of TerminateSubscription */
export type TerminateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of UpdateAddOn */
export type UpdateAddOnInput = {
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** Autogenerated input type of UpdateBillableMetric */
export type UpdateBillableMetricInput = {
  aggregationType: AggregationTypeEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code: Scalars['String'];
  description: Scalars['String'];
  fieldName?: InputMaybe<Scalars['String']>;
  id: Scalars['String'];
  name: Scalars['String'];
};

/** Autogenerated input type of UpdateCoupon */
export type UpdateCouponInput = {
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
  expiration: CouponExpiration;
  expirationDuration?: InputMaybe<Scalars['Int']>;
  id: Scalars['String'];
  name: Scalars['String'];
};

/** Autogenerated input type of UpdateCustomer */
export type UpdateCustomerInput = {
  addressLine1?: InputMaybe<Scalars['String']>;
  addressLine2?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<CountryCode>;
  currency?: InputMaybe<CurrencyEnum>;
  email?: InputMaybe<Scalars['String']>;
  externalId: Scalars['String'];
  id: Scalars['ID'];
  legalName?: InputMaybe<Scalars['String']>;
  legalNumber?: InputMaybe<Scalars['String']>;
  logoUrl?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  paymentProvider?: InputMaybe<ProviderTypeEnum>;
  phone?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  stripeCustomer?: InputMaybe<StripeCustomerInput>;
  url?: InputMaybe<Scalars['String']>;
  vatRate?: InputMaybe<Scalars['Float']>;
  zipcode?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCustomerVatRate */
export type UpdateCustomerVatRateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  vatRate?: InputMaybe<Scalars['Float']>;
};

/** Autogenerated input type of UpdateCustomerWallet */
export type UpdateCustomerWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  expirationDate?: InputMaybe<Scalars['ISO8601Date']>;
  id: Scalars['ID'];
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateOrganization */
export type UpdateOrganizationInput = {
  addressLine1?: InputMaybe<Scalars['String']>;
  addressLine2?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<CountryCode>;
  email?: InputMaybe<Scalars['String']>;
  invoiceFooter?: InputMaybe<Scalars['String']>;
  legalName?: InputMaybe<Scalars['String']>;
  legalNumber?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  vatRate?: InputMaybe<Scalars['Float']>;
  webhookUrl?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of UpdatePlan */
export type UpdatePlanInput = {
  amountCents: Scalars['Int'];
  amountCurrency: CurrencyEnum;
  billChargesMonthly?: InputMaybe<Scalars['Boolean']>;
  charges: Array<ChargeInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  code: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['String'];
  interval: PlanInterval;
  name: Scalars['String'];
  payInAdvance: Scalars['Boolean'];
  trialPeriod?: InputMaybe<Scalars['Float']>;
};

/** Autogenerated input type of UpdateSubscription */
export type UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  organizations?: Maybe<Array<Organization>>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type VolumeRange = {
  __typename?: 'VolumeRange';
  flatAmount: Scalars['String'];
  fromValue: Scalars['Int'];
  perUnitAmount: Scalars['String'];
  toValue?: Maybe<Scalars['Int']>;
};

export type VolumeRangeInput = {
  flatAmount: Scalars['String'];
  fromValue: Scalars['Int'];
  perUnitAmount: Scalars['String'];
  toValue?: InputMaybe<Scalars['Int']>;
};

export type Wallet = {
  __typename?: 'Wallet';
  balance: Scalars['String'];
  consumedAmount: Scalars['String'];
  consumedCredits: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  creditsBalance: Scalars['String'];
  currency: CurrencyEnum;
  customer?: Maybe<Customer>;
  expirationDate?: Maybe<Scalars['ISO8601Date']>;
  id: Scalars['ID'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']>;
  lastConsumedCreditAt?: Maybe<Scalars['ISO8601DateTime']>;
  name: Scalars['String'];
  rateAmount: Scalars['String'];
  status: WalletStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type WalletCollection = {
  __typename?: 'WalletCollection';
  collection: Array<Wallet>;
  metadata: CollectionMetadata;
};

export type WalletDetails = {
  __typename?: 'WalletDetails';
  balance: Scalars['String'];
  consumedAmount: Scalars['String'];
  consumedCredits: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  creditsBalance: Scalars['String'];
  currency: CurrencyEnum;
  customer?: Maybe<Customer>;
  expirationDate?: Maybe<Scalars['ISO8601Date']>;
  id: Scalars['ID'];
  lastBalanceSyncAt?: Maybe<Scalars['ISO8601DateTime']>;
  lastConsumedCreditAt?: Maybe<Scalars['ISO8601DateTime']>;
  name: Scalars['String'];
  rateAmount: Scalars['String'];
  status: WalletStatusEnum;
  terminatedAt?: Maybe<Scalars['ISO8601DateTime']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export enum WalletStatusEnum {
  Active = 'active',
  Terminated = 'terminated',
}

export type WalletTransaction = {
  __typename?: 'WalletTransaction';
  amount: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  creditAmount: Scalars['String'];
  id: Scalars['ID'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']>;
  status: WalletTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime'];
  wallet?: Maybe<Wallet>;
};

export type WalletTransactionCollection = {
  __typename?: 'WalletTransactionCollection';
  collection: Array<WalletTransaction>;
  metadata: CollectionMetadata;
};

export type WalletTransactionDetails = {
  __typename?: 'WalletTransactionDetails';
  amount: Scalars['String'];
  createdAt: Scalars['ISO8601DateTime'];
  creditAmount: Scalars['String'];
  id: Scalars['ID'];
  settledAt?: Maybe<Scalars['ISO8601DateTime']>;
  status: WalletTransactionStatusEnum;
  transactionType: WalletTransactionTransactionTypeEnum;
  updatedAt: Scalars['ISO8601DateTime'];
  wallet?: Maybe<Wallet>;
};

export enum WalletTransactionStatusEnum {
  Pending = 'pending',
  Settled = 'settled',
}

export enum WalletTransactionTransactionTypeEnum {
  Inbound = 'inbound',
  Outbound = 'outbound',
}

export type ResolverTypeWrapper<T> = Promise<T> | T;

export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> {
  subscribe: SubscriptionSubscribeFn<
    { [key in TKey]: TResult },
    TParent,
    TContext,
    TArgs
  >;
  resolve?: SubscriptionResolveFn<
    TResult,
    { [key in TKey]: TResult },
    TContext,
    TArgs
  >;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<
  TResult,
  TKey extends string,
  TParent,
  TContext,
  TArgs
> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<
  TResult,
  TKey extends string,
  TParent = {},
  TContext = {},
  TArgs = {}
> =
  | ((
      ...args: any[]
    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (
  obj: T,
  context: TContext,
  info: GraphQLResolveInfo
) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<
  TResult = {},
  TParent = {},
  TContext = {},
  TArgs = {}
> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AcceptInviteInput: AcceptInviteInput;
  AddOn: ResolverTypeWrapper<AddOn>;
  AddOnCollection: ResolverTypeWrapper<AddOnCollection>;
  AddOnDetails: ResolverTypeWrapper<AddOnDetails>;
  AddStripePaymentProviderInput: AddStripePaymentProviderInput;
  AggregationTypeEnum: AggregationTypeEnum;
  AppliedAddOn: ResolverTypeWrapper<AppliedAddOn>;
  AppliedCoupon: ResolverTypeWrapper<AppliedCoupon>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  BillableMetric: ResolverTypeWrapper<BillableMetric>;
  BillableMetricCollection: ResolverTypeWrapper<BillableMetricCollection>;
  BillableMetricDetail: ResolverTypeWrapper<BillableMetricDetail>;
  BillingTimeEnum: BillingTimeEnum;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Charge: ResolverTypeWrapper<Charge>;
  ChargeInput: ChargeInput;
  ChargeModelEnum: ChargeModelEnum;
  ChargeUsage: ResolverTypeWrapper<ChargeUsage>;
  CollectionMetadata: ResolverTypeWrapper<CollectionMetadata>;
  CountryCode: CountryCode;
  Coupon: ResolverTypeWrapper<Coupon>;
  CouponCollection: ResolverTypeWrapper<CouponCollection>;
  CouponDetails: ResolverTypeWrapper<CouponDetails>;
  CouponExpiration: CouponExpiration;
  CouponStatusEnum: CouponStatusEnum;
  CreateAddOnInput: CreateAddOnInput;
  CreateAppliedAddOnInput: CreateAppliedAddOnInput;
  CreateAppliedCouponInput: CreateAppliedCouponInput;
  CreateBillableMetricInput: CreateBillableMetricInput;
  CreateCouponInput: CreateCouponInput;
  CreateCustomerInput: CreateCustomerInput;
  CreateCustomerWalletInput: CreateCustomerWalletInput;
  CreateCustomerWalletTransactionInput: CreateCustomerWalletTransactionInput;
  CreateInviteInput: CreateInviteInput;
  CreatePlanInput: CreatePlanInput;
  CreateSubscriptionInput: CreateSubscriptionInput;
  CurrencyEnum: CurrencyEnum;
  CurrentVersion: ResolverTypeWrapper<CurrentVersion>;
  Customer: ResolverTypeWrapper<Customer>;
  CustomerCollection: ResolverTypeWrapper<CustomerCollection>;
  CustomerDetails: ResolverTypeWrapper<CustomerDetails>;
  CustomerUsage: ResolverTypeWrapper<CustomerUsage>;
  DestroyAddOnInput: DestroyAddOnInput;
  DestroyAddOnPayload: ResolverTypeWrapper<DestroyAddOnPayload>;
  DestroyBillableMetricInput: DestroyBillableMetricInput;
  DestroyBillableMetricPayload: ResolverTypeWrapper<DestroyBillableMetricPayload>;
  DestroyCouponInput: DestroyCouponInput;
  DestroyCouponPayload: ResolverTypeWrapper<DestroyCouponPayload>;
  DestroyCustomerInput: DestroyCustomerInput;
  DestroyCustomerPayload: ResolverTypeWrapper<DestroyCustomerPayload>;
  DestroyPaymentProviderInput: DestroyPaymentProviderInput;
  DestroyPaymentProviderPayload: ResolverTypeWrapper<DestroyPaymentProviderPayload>;
  DestroyPlanInput: DestroyPlanInput;
  DestroyPlanPayload: ResolverTypeWrapper<DestroyPlanPayload>;
  DownloadInvoiceInput: DownloadInvoiceInput;
  Event: ResolverTypeWrapper<Event>;
  EventCollection: ResolverTypeWrapper<EventCollection>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  GraduatedRange: ResolverTypeWrapper<GraduatedRange>;
  GraduatedRangeInput: GraduatedRangeInput;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  ISO8601Date: ResolverTypeWrapper<Scalars['ISO8601Date']>;
  ISO8601DateTime: ResolverTypeWrapper<Scalars['ISO8601DateTime']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  Invite: ResolverTypeWrapper<Invite>;
  InviteCollection: ResolverTypeWrapper<InviteCollection>;
  InviteStatusTypeEnum: InviteStatusTypeEnum;
  Invoice: ResolverTypeWrapper<Invoice>;
  InvoiceStatusTypeEnum: InvoiceStatusTypeEnum;
  InvoiceTypeEnum: InvoiceTypeEnum;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  LoginUser: ResolverTypeWrapper<LoginUser>;
  LoginUserInput: LoginUserInput;
  Membership: ResolverTypeWrapper<Membership>;
  MembershipCollection: ResolverTypeWrapper<MembershipCollection>;
  MembershipStatus: MembershipStatus;
  Mutation: ResolverTypeWrapper<{}>;
  Organization: ResolverTypeWrapper<Organization>;
  Plan: ResolverTypeWrapper<Plan>;
  PlanCollection: ResolverTypeWrapper<PlanCollection>;
  PlanDetails: ResolverTypeWrapper<PlanDetails>;
  PlanInterval: PlanInterval;
  ProviderTypeEnum: ProviderTypeEnum;
  Query: ResolverTypeWrapper<{}>;
  RegisterUser: ResolverTypeWrapper<RegisterUser>;
  RegisterUserInput: RegisterUserInput;
  RevokeInviteInput: RevokeInviteInput;
  RevokeMembershipInput: RevokeMembershipInput;
  StatusTypeEnum: StatusTypeEnum;
  String: ResolverTypeWrapper<Scalars['String']>;
  StripeCustomer: ResolverTypeWrapper<StripeCustomer>;
  StripeCustomerInput: StripeCustomerInput;
  StripeProvider: ResolverTypeWrapper<StripeProvider>;
  Subscription: ResolverTypeWrapper<Subscription>;
  TerminateAppliedCouponInput: TerminateAppliedCouponInput;
  TerminateCouponInput: TerminateCouponInput;
  TerminateCustomerWalletInput: TerminateCustomerWalletInput;
  TerminateSubscriptionInput: TerminateSubscriptionInput;
  UpdateAddOnInput: UpdateAddOnInput;
  UpdateBillableMetricInput: UpdateBillableMetricInput;
  UpdateCouponInput: UpdateCouponInput;
  UpdateCustomerInput: UpdateCustomerInput;
  UpdateCustomerVatRateInput: UpdateCustomerVatRateInput;
  UpdateCustomerWalletInput: UpdateCustomerWalletInput;
  UpdateOrganizationInput: UpdateOrganizationInput;
  UpdatePlanInput: UpdatePlanInput;
  UpdateSubscriptionInput: UpdateSubscriptionInput;
  User: ResolverTypeWrapper<User>;
  VolumeRange: ResolverTypeWrapper<VolumeRange>;
  VolumeRangeInput: VolumeRangeInput;
  Wallet: ResolverTypeWrapper<Wallet>;
  WalletCollection: ResolverTypeWrapper<WalletCollection>;
  WalletDetails: ResolverTypeWrapper<WalletDetails>;
  WalletStatusEnum: WalletStatusEnum;
  WalletTransaction: ResolverTypeWrapper<WalletTransaction>;
  WalletTransactionCollection: ResolverTypeWrapper<WalletTransactionCollection>;
  WalletTransactionDetails: ResolverTypeWrapper<WalletTransactionDetails>;
  WalletTransactionStatusEnum: WalletTransactionStatusEnum;
  WalletTransactionTransactionTypeEnum: WalletTransactionTransactionTypeEnum;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AcceptInviteInput: AcceptInviteInput;
  AddOn: AddOn;
  AddOnCollection: AddOnCollection;
  AddOnDetails: AddOnDetails;
  AddStripePaymentProviderInput: AddStripePaymentProviderInput;
  AppliedAddOn: AppliedAddOn;
  AppliedCoupon: AppliedCoupon;
  BigInt: Scalars['BigInt'];
  BillableMetric: BillableMetric;
  BillableMetricCollection: BillableMetricCollection;
  BillableMetricDetail: BillableMetricDetail;
  Boolean: Scalars['Boolean'];
  Charge: Charge;
  ChargeInput: ChargeInput;
  ChargeUsage: ChargeUsage;
  CollectionMetadata: CollectionMetadata;
  Coupon: Coupon;
  CouponCollection: CouponCollection;
  CouponDetails: CouponDetails;
  CreateAddOnInput: CreateAddOnInput;
  CreateAppliedAddOnInput: CreateAppliedAddOnInput;
  CreateAppliedCouponInput: CreateAppliedCouponInput;
  CreateBillableMetricInput: CreateBillableMetricInput;
  CreateCouponInput: CreateCouponInput;
  CreateCustomerInput: CreateCustomerInput;
  CreateCustomerWalletInput: CreateCustomerWalletInput;
  CreateCustomerWalletTransactionInput: CreateCustomerWalletTransactionInput;
  CreateInviteInput: CreateInviteInput;
  CreatePlanInput: CreatePlanInput;
  CreateSubscriptionInput: CreateSubscriptionInput;
  CurrentVersion: CurrentVersion;
  Customer: Customer;
  CustomerCollection: CustomerCollection;
  CustomerDetails: CustomerDetails;
  CustomerUsage: CustomerUsage;
  DestroyAddOnInput: DestroyAddOnInput;
  DestroyAddOnPayload: DestroyAddOnPayload;
  DestroyBillableMetricInput: DestroyBillableMetricInput;
  DestroyBillableMetricPayload: DestroyBillableMetricPayload;
  DestroyCouponInput: DestroyCouponInput;
  DestroyCouponPayload: DestroyCouponPayload;
  DestroyCustomerInput: DestroyCustomerInput;
  DestroyCustomerPayload: DestroyCustomerPayload;
  DestroyPaymentProviderInput: DestroyPaymentProviderInput;
  DestroyPaymentProviderPayload: DestroyPaymentProviderPayload;
  DestroyPlanInput: DestroyPlanInput;
  DestroyPlanPayload: DestroyPlanPayload;
  DownloadInvoiceInput: DownloadInvoiceInput;
  Event: Event;
  EventCollection: EventCollection;
  Float: Scalars['Float'];
  GraduatedRange: GraduatedRange;
  GraduatedRangeInput: GraduatedRangeInput;
  ID: Scalars['ID'];
  ISO8601Date: Scalars['ISO8601Date'];
  ISO8601DateTime: Scalars['ISO8601DateTime'];
  Int: Scalars['Int'];
  Invite: Invite;
  InviteCollection: InviteCollection;
  Invoice: Invoice;
  JSON: Scalars['JSON'];
  LoginUser: LoginUser;
  LoginUserInput: LoginUserInput;
  Membership: Membership;
  MembershipCollection: MembershipCollection;
  Mutation: {};
  Organization: Organization;
  Plan: Plan;
  PlanCollection: PlanCollection;
  PlanDetails: PlanDetails;
  Query: {};
  RegisterUser: RegisterUser;
  RegisterUserInput: RegisterUserInput;
  RevokeInviteInput: RevokeInviteInput;
  RevokeMembershipInput: RevokeMembershipInput;
  String: Scalars['String'];
  StripeCustomer: StripeCustomer;
  StripeCustomerInput: StripeCustomerInput;
  StripeProvider: StripeProvider;
  Subscription: Subscription;
  TerminateAppliedCouponInput: TerminateAppliedCouponInput;
  TerminateCouponInput: TerminateCouponInput;
  TerminateCustomerWalletInput: TerminateCustomerWalletInput;
  TerminateSubscriptionInput: TerminateSubscriptionInput;
  UpdateAddOnInput: UpdateAddOnInput;
  UpdateBillableMetricInput: UpdateBillableMetricInput;
  UpdateCouponInput: UpdateCouponInput;
  UpdateCustomerInput: UpdateCustomerInput;
  UpdateCustomerVatRateInput: UpdateCustomerVatRateInput;
  UpdateCustomerWalletInput: UpdateCustomerWalletInput;
  UpdateOrganizationInput: UpdateOrganizationInput;
  UpdatePlanInput: UpdatePlanInput;
  UpdateSubscriptionInput: UpdateSubscriptionInput;
  User: User;
  VolumeRange: VolumeRange;
  VolumeRangeInput: VolumeRangeInput;
  Wallet: Wallet;
  WalletCollection: WalletCollection;
  WalletDetails: WalletDetails;
  WalletTransaction: WalletTransaction;
  WalletTransactionCollection: WalletTransactionCollection;
  WalletTransactionDetails: WalletTransactionDetails;
};

export type AddOnResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['AddOn'] = ResolversParentTypes['AddOn']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddOnCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['AddOnCollection'] = ResolversParentTypes['AddOnCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['AddOn']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddOnDetailsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['AddOnDetails'] = ResolversParentTypes['AddOnDetails']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppliedAddOnResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['AppliedAddOn'] = ResolversParentTypes['AppliedAddOn']
> = {
  addOn?: Resolver<ResolversTypes['AddOn'], ParentType, ContextType>;
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppliedCouponResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['AppliedCoupon'] = ResolversParentTypes['AppliedCoupon']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  coupon?: Resolver<ResolversTypes['Coupon'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  terminatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type BillableMetricResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['BillableMetric'] = ResolversParentTypes['BillableMetric']
> = {
  aggregationType?: Resolver<
    ResolversTypes['AggregationTypeEnum'],
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  fieldName?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BillableMetricCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['BillableMetricCollection'] = ResolversParentTypes['BillableMetricCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['BillableMetric']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BillableMetricDetailResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['BillableMetricDetail'] = ResolversParentTypes['BillableMetricDetail']
> = {
  aggregationType?: Resolver<
    ResolversTypes['AggregationTypeEnum'],
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  description?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  fieldName?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChargeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Charge'] = ResolversParentTypes['Charge']
> = {
  amount?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  billableMetric?: Resolver<
    ResolversTypes['BillableMetric'],
    ParentType,
    ContextType
  >;
  chargeModel?: Resolver<
    ResolversTypes['ChargeModelEnum'],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  fixedAmount?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  freeUnits?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  freeUnitsPerEvents?: Resolver<
    Maybe<ResolversTypes['Int']>,
    ParentType,
    ContextType
  >;
  freeUnitsPerTotalAggregation?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  graduatedRanges?: Resolver<
    Maybe<Array<ResolversTypes['GraduatedRange']>>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  packageSize?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  rate?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  volumeRanges?: Resolver<
    Maybe<Array<ResolversTypes['VolumeRange']>>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChargeUsageResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['ChargeUsage'] = ResolversParentTypes['ChargeUsage']
> = {
  amountCents?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  billableMetric?: Resolver<
    ResolversTypes['BillableMetric'],
    ParentType,
    ContextType
  >;
  charge?: Resolver<ResolversTypes['Charge'], ParentType, ContextType>;
  units?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionMetadataResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CollectionMetadata'] = ResolversParentTypes['CollectionMetadata']
> = {
  currentPage?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  limitValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalPages?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CouponResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Coupon'] = ResolversParentTypes['Coupon']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  expiration?: Resolver<
    ResolversTypes['CouponExpiration'],
    ParentType,
    ContextType
  >;
  expirationDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  expirationDuration?: Resolver<
    Maybe<ResolversTypes['Int']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes['CouponStatusEnum'],
    ParentType,
    ContextType
  >;
  terminatedAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CouponCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CouponCollection'] = ResolversParentTypes['CouponCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['Coupon']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CouponDetailsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CouponDetails'] = ResolversParentTypes['CouponDetails']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  expiration?: Resolver<
    ResolversTypes['CouponExpiration'],
    ParentType,
    ContextType
  >;
  expirationDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  expirationDuration?: Resolver<
    Maybe<ResolversTypes['Int']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes['CouponStatusEnum'],
    ParentType,
    ContextType
  >;
  terminatedAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CurrentVersionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CurrentVersion'] = ResolversParentTypes['CurrentVersion']
> = {
  githubUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Customer'] = ResolversParentTypes['Customer']
> = {
  activeSubscriptionCount?: Resolver<
    ResolversTypes['Int'],
    ParentType,
    ContextType
  >;
  addressLine1?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  addressLine2?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<
    Maybe<ResolversTypes['CountryCode']>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  currency?: Resolver<
    Maybe<ResolversTypes['CurrencyEnum']>,
    ParentType,
    ContextType
  >;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hasActiveWallet?: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  legalName?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  legalNumber?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  logoUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentProvider?: Resolver<
    Maybe<ResolversTypes['ProviderTypeEnum']>,
    ParentType,
    ContextType
  >;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sequentialId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stripeCustomer?: Resolver<
    Maybe<ResolversTypes['StripeCustomer']>,
    ParentType,
    ContextType
  >;
  subscriptions?: Resolver<
    Maybe<Array<ResolversTypes['Subscription']>>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vatRate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  zipcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CustomerCollection'] = ResolversParentTypes['CustomerCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['Customer']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerDetailsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CustomerDetails'] = ResolversParentTypes['CustomerDetails']
> = {
  activeSubscriptionCount?: Resolver<
    ResolversTypes['Int'],
    ParentType,
    ContextType
  >;
  addressLine1?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  addressLine2?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  appliedAddOns?: Resolver<
    Maybe<Array<ResolversTypes['AppliedAddOn']>>,
    ParentType,
    ContextType
  >;
  appliedCoupons?: Resolver<
    Maybe<Array<ResolversTypes['AppliedCoupon']>>,
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<
    Maybe<ResolversTypes['CountryCode']>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  currency?: Resolver<
    Maybe<ResolversTypes['CurrencyEnum']>,
    ParentType,
    ContextType
  >;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  externalId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  hasActiveWallet?: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoices?: Resolver<
    Maybe<Array<ResolversTypes['Invoice']>>,
    ParentType,
    ContextType
  >;
  legalName?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  legalNumber?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  logoUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentProvider?: Resolver<
    Maybe<ResolversTypes['ProviderTypeEnum']>,
    ParentType,
    ContextType
  >;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sequentialId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stripeCustomer?: Resolver<
    Maybe<ResolversTypes['StripeCustomer']>,
    ParentType,
    ContextType
  >;
  subscriptions?: Resolver<
    Array<ResolversTypes['Subscription']>,
    ParentType,
    ContextType,
    Partial<CustomerDetailsSubscriptionsArgs>
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  vatRate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  zipcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerUsageResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['CustomerUsage'] = ResolversParentTypes['CustomerUsage']
> = {
  amountCents?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  chargesUsage?: Resolver<
    Array<ResolversTypes['ChargeUsage']>,
    ParentType,
    ContextType
  >;
  fromDate?: Resolver<ResolversTypes['ISO8601Date'], ParentType, ContextType>;
  issuingDate?: Resolver<
    ResolversTypes['ISO8601Date'],
    ParentType,
    ContextType
  >;
  toDate?: Resolver<ResolversTypes['ISO8601Date'], ParentType, ContextType>;
  totalAmountCents?: Resolver<
    ResolversTypes['BigInt'],
    ParentType,
    ContextType
  >;
  totalAmountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  vatAmountCents?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
  vatAmountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyAddOnPayloadResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['DestroyAddOnPayload'] = ResolversParentTypes['DestroyAddOnPayload']
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyBillableMetricPayloadResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['DestroyBillableMetricPayload'] = ResolversParentTypes['DestroyBillableMetricPayload']
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyCouponPayloadResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['DestroyCouponPayload'] = ResolversParentTypes['DestroyCouponPayload']
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyCustomerPayloadResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['DestroyCustomerPayload'] = ResolversParentTypes['DestroyCustomerPayload']
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyPaymentProviderPayloadResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['DestroyPaymentProviderPayload'] = ResolversParentTypes['DestroyPaymentProviderPayload']
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DestroyPlanPayloadResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['DestroyPlanPayload'] = ResolversParentTypes['DestroyPlanPayload']
> = {
  clientMutationId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']
> = {
  apiClient?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  billableMetricName?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  externalCustomerId?: Resolver<
    ResolversTypes['String'],
    ParentType,
    ContextType
  >;
  externalSubscriptionId?: Resolver<
    ResolversTypes['String'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  ipAddress?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  matchBillableMetric?: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  matchCustomField?: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  payload?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  receivedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  timestamp?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  transactionId?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['EventCollection'] = ResolversParentTypes['EventCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['Event']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GraduatedRangeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['GraduatedRange'] = ResolversParentTypes['GraduatedRange']
> = {
  flatAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fromValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  perUnitAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toValue?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface Iso8601DateScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601Date'], any> {
  name: 'ISO8601Date';
}

export interface Iso8601DateTimeScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['ISO8601DateTime'], any> {
  name: 'ISO8601DateTime';
}

export type InviteResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Invite'] = ResolversParentTypes['Invite']
> = {
  acceptedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organization?: Resolver<
    ResolversTypes['Organization'],
    ParentType,
    ContextType
  >;
  recipient?: Resolver<ResolversTypes['Membership'], ParentType, ContextType>;
  revokedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes['InviteStatusTypeEnum'],
    ParentType,
    ContextType
  >;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InviteCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['InviteCollection'] = ResolversParentTypes['InviteCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['Invite']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Invoice'] = ResolversParentTypes['Invoice']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  fileUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoiceType?: Resolver<
    ResolversTypes['InvoiceTypeEnum'],
    ParentType,
    ContextType
  >;
  issuingDate?: Resolver<
    ResolversTypes['ISO8601Date'],
    ParentType,
    ContextType
  >;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  plan?: Resolver<Maybe<ResolversTypes['Plan']>, ParentType, ContextType>;
  sequentialId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  status?: Resolver<
    ResolversTypes['InvoiceStatusTypeEnum'],
    ParentType,
    ContextType
  >;
  subscription?: Resolver<
    Maybe<ResolversTypes['Subscription']>,
    ParentType,
    ContextType
  >;
  totalAmountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  totalAmountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  vatAmountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  vatAmountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonScalarConfig
  extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type LoginUserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['LoginUser'] = ResolversParentTypes['LoginUser']
> = {
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MembershipResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Membership'] = ResolversParentTypes['Membership']
> = {
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organization?: Resolver<
    ResolversTypes['Organization'],
    ParentType,
    ContextType
  >;
  revokedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  role?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<
    ResolversTypes['MembershipStatus'],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MembershipCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['MembershipCollection'] = ResolversParentTypes['MembershipCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['Membership']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']
> = {
  acceptInvite?: Resolver<
    Maybe<ResolversTypes['RegisterUser']>,
    ParentType,
    ContextType,
    RequireFields<MutationAcceptInviteArgs, 'input'>
  >;
  addStripePaymentProvider?: Resolver<
    Maybe<ResolversTypes['StripeProvider']>,
    ParentType,
    ContextType,
    RequireFields<MutationAddStripePaymentProviderArgs, 'input'>
  >;
  createAddOn?: Resolver<
    Maybe<ResolversTypes['AddOn']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateAddOnArgs, 'input'>
  >;
  createAppliedAddOn?: Resolver<
    Maybe<ResolversTypes['AppliedAddOn']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateAppliedAddOnArgs, 'input'>
  >;
  createAppliedCoupon?: Resolver<
    Maybe<ResolversTypes['AppliedCoupon']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateAppliedCouponArgs, 'input'>
  >;
  createBillableMetric?: Resolver<
    Maybe<ResolversTypes['BillableMetric']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateBillableMetricArgs, 'input'>
  >;
  createCoupon?: Resolver<
    Maybe<ResolversTypes['Coupon']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCouponArgs, 'input'>
  >;
  createCustomer?: Resolver<
    Maybe<ResolversTypes['Customer']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCustomerArgs, 'input'>
  >;
  createCustomerWallet?: Resolver<
    Maybe<ResolversTypes['Wallet']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCustomerWalletArgs, 'input'>
  >;
  createCustomerWalletTransaction?: Resolver<
    Maybe<ResolversTypes['WalletTransactionCollection']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateCustomerWalletTransactionArgs, 'input'>
  >;
  createInvite?: Resolver<
    Maybe<ResolversTypes['Invite']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateInviteArgs, 'input'>
  >;
  createPlan?: Resolver<
    Maybe<ResolversTypes['Plan']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreatePlanArgs, 'input'>
  >;
  createSubscription?: Resolver<
    Maybe<ResolversTypes['Subscription']>,
    ParentType,
    ContextType,
    RequireFields<MutationCreateSubscriptionArgs, 'input'>
  >;
  destroyAddOn?: Resolver<
    Maybe<ResolversTypes['DestroyAddOnPayload']>,
    ParentType,
    ContextType,
    RequireFields<MutationDestroyAddOnArgs, 'input'>
  >;
  destroyBillableMetric?: Resolver<
    Maybe<ResolversTypes['DestroyBillableMetricPayload']>,
    ParentType,
    ContextType,
    RequireFields<MutationDestroyBillableMetricArgs, 'input'>
  >;
  destroyCoupon?: Resolver<
    Maybe<ResolversTypes['DestroyCouponPayload']>,
    ParentType,
    ContextType,
    RequireFields<MutationDestroyCouponArgs, 'input'>
  >;
  destroyCustomer?: Resolver<
    Maybe<ResolversTypes['DestroyCustomerPayload']>,
    ParentType,
    ContextType,
    RequireFields<MutationDestroyCustomerArgs, 'input'>
  >;
  destroyPaymentProvider?: Resolver<
    Maybe<ResolversTypes['DestroyPaymentProviderPayload']>,
    ParentType,
    ContextType,
    RequireFields<MutationDestroyPaymentProviderArgs, 'input'>
  >;
  destroyPlan?: Resolver<
    Maybe<ResolversTypes['DestroyPlanPayload']>,
    ParentType,
    ContextType,
    RequireFields<MutationDestroyPlanArgs, 'input'>
  >;
  downloadInvoice?: Resolver<
    Maybe<ResolversTypes['Invoice']>,
    ParentType,
    ContextType,
    RequireFields<MutationDownloadInvoiceArgs, 'input'>
  >;
  loginUser?: Resolver<
    Maybe<ResolversTypes['LoginUser']>,
    ParentType,
    ContextType,
    RequireFields<MutationLoginUserArgs, 'input'>
  >;
  registerUser?: Resolver<
    Maybe<ResolversTypes['RegisterUser']>,
    ParentType,
    ContextType,
    RequireFields<MutationRegisterUserArgs, 'input'>
  >;
  revokeInvite?: Resolver<
    Maybe<ResolversTypes['Invite']>,
    ParentType,
    ContextType,
    RequireFields<MutationRevokeInviteArgs, 'input'>
  >;
  revokeMembership?: Resolver<
    Maybe<ResolversTypes['Membership']>,
    ParentType,
    ContextType,
    RequireFields<MutationRevokeMembershipArgs, 'input'>
  >;
  terminateAppliedCoupon?: Resolver<
    Maybe<ResolversTypes['AppliedCoupon']>,
    ParentType,
    ContextType,
    RequireFields<MutationTerminateAppliedCouponArgs, 'input'>
  >;
  terminateCoupon?: Resolver<
    Maybe<ResolversTypes['Coupon']>,
    ParentType,
    ContextType,
    RequireFields<MutationTerminateCouponArgs, 'input'>
  >;
  terminateCustomerWallet?: Resolver<
    Maybe<ResolversTypes['Wallet']>,
    ParentType,
    ContextType,
    RequireFields<MutationTerminateCustomerWalletArgs, 'input'>
  >;
  terminateSubscription?: Resolver<
    Maybe<ResolversTypes['Subscription']>,
    ParentType,
    ContextType,
    RequireFields<MutationTerminateSubscriptionArgs, 'input'>
  >;
  updateAddOn?: Resolver<
    Maybe<ResolversTypes['AddOn']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateAddOnArgs, 'input'>
  >;
  updateBillableMetric?: Resolver<
    Maybe<ResolversTypes['BillableMetric']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateBillableMetricArgs, 'input'>
  >;
  updateCoupon?: Resolver<
    Maybe<ResolversTypes['Coupon']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCouponArgs, 'input'>
  >;
  updateCustomer?: Resolver<
    Maybe<ResolversTypes['Customer']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCustomerArgs, 'input'>
  >;
  updateCustomerVatRate?: Resolver<
    Maybe<ResolversTypes['CustomerDetails']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCustomerVatRateArgs, 'input'>
  >;
  updateCustomerWallet?: Resolver<
    Maybe<ResolversTypes['Wallet']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateCustomerWalletArgs, 'input'>
  >;
  updateOrganization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateOrganizationArgs, 'input'>
  >;
  updatePlan?: Resolver<
    Maybe<ResolversTypes['Plan']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdatePlanArgs, 'input'>
  >;
  updateSubscription?: Resolver<
    Maybe<ResolversTypes['Subscription']>,
    ParentType,
    ContextType,
    RequireFields<MutationUpdateSubscriptionArgs, 'input'>
  >;
};

export type OrganizationResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Organization'] = ResolversParentTypes['Organization']
> = {
  addressLine1?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  addressLine2?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  apiKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  city?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<
    Maybe<ResolversTypes['CountryCode']>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoiceFooter?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  legalName?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  legalNumber?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  logoUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  state?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stripePaymentProvider?: Resolver<
    Maybe<ResolversTypes['StripeProvider']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  vatRate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  webhookUrl?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  zipcode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PlanResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Plan'] = ResolversParentTypes['Plan']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  billChargesMonthly?: Resolver<
    Maybe<ResolversTypes['Boolean']>,
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  chargeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  charges?: Resolver<
    Maybe<Array<ResolversTypes['Charge']>>,
    ParentType,
    ContextType
  >;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interval?: Resolver<ResolversTypes['PlanInterval'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  parentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  payInAdvance?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  trialPeriod?: Resolver<
    Maybe<ResolversTypes['Float']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PlanCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['PlanCollection'] = ResolversParentTypes['PlanCollection']
> = {
  collection?: Resolver<Array<ResolversTypes['Plan']>, ParentType, ContextType>;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PlanDetailsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['PlanDetails'] = ResolversParentTypes['PlanDetails']
> = {
  amountCents?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  amountCurrency?: Resolver<
    ResolversTypes['CurrencyEnum'],
    ParentType,
    ContextType
  >;
  billChargesMonthly?: Resolver<
    Maybe<ResolversTypes['Boolean']>,
    ParentType,
    ContextType
  >;
  canBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  chargeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  charges?: Resolver<
    Maybe<Array<ResolversTypes['Charge']>>,
    ParentType,
    ContextType
  >;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customerCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  description?: Resolver<
    Maybe<ResolversTypes['String']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  interval?: Resolver<ResolversTypes['PlanInterval'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  organization?: Resolver<
    Maybe<ResolversTypes['Organization']>,
    ParentType,
    ContextType
  >;
  parentId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  payInAdvance?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  trialPeriod?: Resolver<
    Maybe<ResolversTypes['Float']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']
> = {
  addOn?: Resolver<
    Maybe<ResolversTypes['AddOnDetails']>,
    ParentType,
    ContextType,
    RequireFields<QueryAddOnArgs, 'id'>
  >;
  addOns?: Resolver<
    ResolversTypes['AddOnCollection'],
    ParentType,
    ContextType,
    Partial<QueryAddOnsArgs>
  >;
  billableMetric?: Resolver<
    Maybe<ResolversTypes['BillableMetricDetail']>,
    ParentType,
    ContextType,
    RequireFields<QueryBillableMetricArgs, 'id'>
  >;
  billableMetrics?: Resolver<
    ResolversTypes['BillableMetricCollection'],
    ParentType,
    ContextType,
    Partial<QueryBillableMetricsArgs>
  >;
  coupon?: Resolver<
    Maybe<ResolversTypes['CouponDetails']>,
    ParentType,
    ContextType,
    RequireFields<QueryCouponArgs, 'id'>
  >;
  coupons?: Resolver<
    ResolversTypes['CouponCollection'],
    ParentType,
    ContextType,
    Partial<QueryCouponsArgs>
  >;
  currentUser?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  currentVersion?: Resolver<
    ResolversTypes['CurrentVersion'],
    ParentType,
    ContextType
  >;
  customer?: Resolver<
    Maybe<ResolversTypes['CustomerDetails']>,
    ParentType,
    ContextType,
    RequireFields<QueryCustomerArgs, 'id'>
  >;
  customerUsage?: Resolver<
    ResolversTypes['CustomerUsage'],
    ParentType,
    ContextType,
    RequireFields<QueryCustomerUsageArgs, 'subscriptionId'>
  >;
  customers?: Resolver<
    ResolversTypes['CustomerCollection'],
    ParentType,
    ContextType,
    Partial<QueryCustomersArgs>
  >;
  events?: Resolver<
    Maybe<ResolversTypes['EventCollection']>,
    ParentType,
    ContextType,
    Partial<QueryEventsArgs>
  >;
  invite?: Resolver<
    Maybe<ResolversTypes['Invite']>,
    ParentType,
    ContextType,
    RequireFields<QueryInviteArgs, 'token'>
  >;
  invites?: Resolver<
    ResolversTypes['InviteCollection'],
    ParentType,
    ContextType,
    Partial<QueryInvitesArgs>
  >;
  memberships?: Resolver<
    ResolversTypes['MembershipCollection'],
    ParentType,
    ContextType,
    Partial<QueryMembershipsArgs>
  >;
  plan?: Resolver<
    Maybe<ResolversTypes['PlanDetails']>,
    ParentType,
    ContextType,
    RequireFields<QueryPlanArgs, 'id'>
  >;
  plans?: Resolver<
    ResolversTypes['PlanCollection'],
    ParentType,
    ContextType,
    Partial<QueryPlansArgs>
  >;
  wallet?: Resolver<
    Maybe<ResolversTypes['WalletDetails']>,
    ParentType,
    ContextType,
    RequireFields<QueryWalletArgs, 'id'>
  >;
  walletTransaction?: Resolver<
    Maybe<ResolversTypes['WalletTransactionDetails']>,
    ParentType,
    ContextType,
    RequireFields<QueryWalletTransactionArgs, 'id'>
  >;
  walletTransactions?: Resolver<
    ResolversTypes['WalletTransactionCollection'],
    ParentType,
    ContextType,
    RequireFields<QueryWalletTransactionsArgs, 'walletId'>
  >;
  wallets?: Resolver<
    ResolversTypes['WalletCollection'],
    ParentType,
    ContextType,
    RequireFields<QueryWalletsArgs, 'customerId'>
  >;
};

export type RegisterUserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['RegisterUser'] = ResolversParentTypes['RegisterUser']
> = {
  membership?: Resolver<ResolversTypes['Membership'], ParentType, ContextType>;
  organization?: Resolver<
    ResolversTypes['Organization'],
    ParentType,
    ContextType
  >;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StripeCustomerResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['StripeCustomer'] = ResolversParentTypes['StripeCustomer']
> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  providerCustomerId?: Resolver<
    Maybe<ResolversTypes['ID']>,
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StripeProviderResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['StripeProvider'] = ResolversParentTypes['StripeProvider']
> = {
  createCustomers?: Resolver<
    ResolversTypes['Boolean'],
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  secretKey?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscriptionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']
> = {
  billingTime?: Resolver<
    Maybe<ResolversTypes['BillingTimeEnum']>,
    ParentType,
    ContextType
  >;
  canceledAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  customer?: Resolver<ResolversTypes['Customer'], ParentType, ContextType>;
  externalId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nextName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nextPendingStartDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  nextPlan?: Resolver<Maybe<ResolversTypes['Plan']>, ParentType, ContextType>;
  periodEndDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  plan?: Resolver<ResolversTypes['Plan'], ParentType, ContextType>;
  startedAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    Maybe<ResolversTypes['StatusTypeEnum']>,
    ParentType,
    ContextType
  >;
  subscriptionDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  terminatedAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']
> = {
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organizations?: Resolver<
    Maybe<Array<ResolversTypes['Organization']>>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VolumeRangeResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['VolumeRange'] = ResolversParentTypes['VolumeRange']
> = {
  flatAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fromValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  perUnitAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  toValue?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WalletResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['Wallet'] = ResolversParentTypes['Wallet']
> = {
  balance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  consumedAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  consumedCredits?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  creditsBalance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['CurrencyEnum'], ParentType, ContextType>;
  customer?: Resolver<
    Maybe<ResolversTypes['Customer']>,
    ParentType,
    ContextType
  >;
  expirationDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastBalanceSyncAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  lastConsumedCreditAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rateAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<
    ResolversTypes['WalletStatusEnum'],
    ParentType,
    ContextType
  >;
  terminatedAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WalletCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['WalletCollection'] = ResolversParentTypes['WalletCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['Wallet']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WalletDetailsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['WalletDetails'] = ResolversParentTypes['WalletDetails']
> = {
  balance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  consumedAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  consumedCredits?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  creditsBalance?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['CurrencyEnum'], ParentType, ContextType>;
  customer?: Resolver<
    Maybe<ResolversTypes['Customer']>,
    ParentType,
    ContextType
  >;
  expirationDate?: Resolver<
    Maybe<ResolversTypes['ISO8601Date']>,
    ParentType,
    ContextType
  >;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastBalanceSyncAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  lastConsumedCreditAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  rateAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  status?: Resolver<
    ResolversTypes['WalletStatusEnum'],
    ParentType,
    ContextType
  >;
  terminatedAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WalletTransactionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['WalletTransaction'] = ResolversParentTypes['WalletTransaction']
> = {
  amount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  creditAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  settledAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes['WalletTransactionStatusEnum'],
    ParentType,
    ContextType
  >;
  transactionType?: Resolver<
    ResolversTypes['WalletTransactionTransactionTypeEnum'],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  wallet?: Resolver<Maybe<ResolversTypes['Wallet']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WalletTransactionCollectionResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['WalletTransactionCollection'] = ResolversParentTypes['WalletTransactionCollection']
> = {
  collection?: Resolver<
    Array<ResolversTypes['WalletTransaction']>,
    ParentType,
    ContextType
  >;
  metadata?: Resolver<
    ResolversTypes['CollectionMetadata'],
    ParentType,
    ContextType
  >;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WalletTransactionDetailsResolvers<
  ContextType = any,
  ParentType extends ResolversParentTypes['WalletTransactionDetails'] = ResolversParentTypes['WalletTransactionDetails']
> = {
  amount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  creditAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  settledAt?: Resolver<
    Maybe<ResolversTypes['ISO8601DateTime']>,
    ParentType,
    ContextType
  >;
  status?: Resolver<
    ResolversTypes['WalletTransactionStatusEnum'],
    ParentType,
    ContextType
  >;
  transactionType?: Resolver<
    ResolversTypes['WalletTransactionTransactionTypeEnum'],
    ParentType,
    ContextType
  >;
  updatedAt?: Resolver<
    ResolversTypes['ISO8601DateTime'],
    ParentType,
    ContextType
  >;
  wallet?: Resolver<Maybe<ResolversTypes['Wallet']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AddOn?: AddOnResolvers<ContextType>;
  AddOnCollection?: AddOnCollectionResolvers<ContextType>;
  AddOnDetails?: AddOnDetailsResolvers<ContextType>;
  AppliedAddOn?: AppliedAddOnResolvers<ContextType>;
  AppliedCoupon?: AppliedCouponResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  BillableMetric?: BillableMetricResolvers<ContextType>;
  BillableMetricCollection?: BillableMetricCollectionResolvers<ContextType>;
  BillableMetricDetail?: BillableMetricDetailResolvers<ContextType>;
  Charge?: ChargeResolvers<ContextType>;
  ChargeUsage?: ChargeUsageResolvers<ContextType>;
  CollectionMetadata?: CollectionMetadataResolvers<ContextType>;
  Coupon?: CouponResolvers<ContextType>;
  CouponCollection?: CouponCollectionResolvers<ContextType>;
  CouponDetails?: CouponDetailsResolvers<ContextType>;
  CurrentVersion?: CurrentVersionResolvers<ContextType>;
  Customer?: CustomerResolvers<ContextType>;
  CustomerCollection?: CustomerCollectionResolvers<ContextType>;
  CustomerDetails?: CustomerDetailsResolvers<ContextType>;
  CustomerUsage?: CustomerUsageResolvers<ContextType>;
  DestroyAddOnPayload?: DestroyAddOnPayloadResolvers<ContextType>;
  DestroyBillableMetricPayload?: DestroyBillableMetricPayloadResolvers<ContextType>;
  DestroyCouponPayload?: DestroyCouponPayloadResolvers<ContextType>;
  DestroyCustomerPayload?: DestroyCustomerPayloadResolvers<ContextType>;
  DestroyPaymentProviderPayload?: DestroyPaymentProviderPayloadResolvers<ContextType>;
  DestroyPlanPayload?: DestroyPlanPayloadResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  EventCollection?: EventCollectionResolvers<ContextType>;
  GraduatedRange?: GraduatedRangeResolvers<ContextType>;
  ISO8601Date?: GraphQLScalarType;
  ISO8601DateTime?: GraphQLScalarType;
  Invite?: InviteResolvers<ContextType>;
  InviteCollection?: InviteCollectionResolvers<ContextType>;
  Invoice?: InvoiceResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  LoginUser?: LoginUserResolvers<ContextType>;
  Membership?: MembershipResolvers<ContextType>;
  MembershipCollection?: MembershipCollectionResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Organization?: OrganizationResolvers<ContextType>;
  Plan?: PlanResolvers<ContextType>;
  PlanCollection?: PlanCollectionResolvers<ContextType>;
  PlanDetails?: PlanDetailsResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  RegisterUser?: RegisterUserResolvers<ContextType>;
  StripeCustomer?: StripeCustomerResolvers<ContextType>;
  StripeProvider?: StripeProviderResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  VolumeRange?: VolumeRangeResolvers<ContextType>;
  Wallet?: WalletResolvers<ContextType>;
  WalletCollection?: WalletCollectionResolvers<ContextType>;
  WalletDetails?: WalletDetailsResolvers<ContextType>;
  WalletTransaction?: WalletTransactionResolvers<ContextType>;
  WalletTransactionCollection?: WalletTransactionCollectionResolvers<ContextType>;
  WalletTransactionDetails?: WalletTransactionDetailsResolvers<ContextType>;
};
